#!/usr/bin/env bash

# TODO -


# Métodos para pegar as informações de id's do arquivo
get_id_file(){
	echo "$1"
}

get_id_desktop_file(){
	ID_DESKTOP_FILE=$(get_id_file "$1")
}

get_id_window_file(){
	ID_WINS_FILE+=("$(get_id_file "$1")")
}

# Cria arquivo que contém os id's das leafs
create_array_file(){
	printf '%s\n' "get_id_desktop_file $ID_DESKTOP" > "$ARQUIVO_ID_WINDOWS" 
	for id in ${ID_WINS[@]}
	do
		printf '%s\n' "get_id_window_file $id" >> "$ARQUIVO_ID_WINDOWS"
	done
}

# Pega o DESKTOP em foco
get_desktop(){
	ID_DESKTOP=$(bspc query -D -d focused)
}

# Pega somente as leafs do DESKTOP em foco
get_windows(){
	ID_WINS=()
	for id in $(bspc query -N -d focused -n .leaf)
	do
		ID_WINS+=("$id")
	done
}

# Retornar índice do node no array
get_window_indice(){
	local indice_id=
	local num=0
	local is_id_focused=$(bspc query -N -n)
	for id in ${ID_WINS[@]}
	do
		[[ $is_id_focused == $id ]] && indice_id="$num" && break
		((num++))
	done
	echo "$indice_id"
	
}

verify_limit(){
	local max_indice=$(( ${#ID_WINS[@]} - 1 ))
	if (( $1 > $max_indice ))
	then
		echo "0"
	elif (( $1 < 0 ))
	then
		echo "$max_indice"
	elif (( $1 >= 0 )) && (( $1 <= $max_indice ))
	then
		echo "$1"
	fi
}

get_info_from_file(){
	ID_DESKTOP_FILE=
	ID_WINS_FILE=()
	# Lê as informações do arquivo, se ele existir
	[[ -e $ARQUIVO_ID_WINDOWS ]] &&
	while read ids_file
	do
		$ids_file
	done < "$ARQUIVO_ID_WINDOWS"
}

choosing_info(){
	# Verificar se mudou de DESKTOP. Caso não tenha mudado, usar os id's do arquivo
	# Verificar se ID_WINS é igual a ID_WINS_FILE
	if [[ $ID_DESKTOP_FILE == $ID_DESKTOP ]] && [[ ${#ID_WINS_FILE[@]} == ${#ID_WINS[@]} ]]
	then
		ID_DESKTOP="$ID_DESKTOP_FILE"
		ID_WINS=("${ID_WINS_FILE[@]}")
	else
		create_array_file
	fi
}

init_modules(){
	get_desktop
	get_windows
	get_info_from_file
	choosing_info
}

select_next_window(){
	# Como fazer o array ser persistente? Criar um arquivo que contenha essas informações
	init_modules

	local indice=
	
	case "$1" in
		next)
			indice=$(verify_limit "$(( $(get_window_indice) + 1 ))")
			;;
		prev)
			indice=$(verify_limit "$(( $(get_window_indice) - 1 ))")
			;;
		*)
			notify-send -t 3000 "BSPSN" "Comando não reconhecido!"
			;;
	esac

	bspc node -f "${ID_WINS[$indice]}"
}

# Método recebe valores {prev,next} e foca a leaf respectiva
main(){
	ARQUIVO_ID_WINDOWS="$HOME"/.config/bspwm/.desktop_ids.bspsn
	select_next_window "$1"
}

main "$@"
