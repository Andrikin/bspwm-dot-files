#!/usr/bin/env bash

# TODO - 
# Este script estará sempre rodando em background

# "Printa" número de NODE's no DESKTOP em foco
get_leaf_number(){
	local num_windows=0
	for id in $(bspc query -N -d "$1" -n .leaf)
	do
		((num_windows++))
	done

	echo "$num_windows"
}

set_window_whxy(){
	[[ ${WINDOW_RESIZED[$1]} != 0 ]] && 
		{
			# Redimensiona o NODE
			xdo resize -w 1092 -h 614 # Width, heigth 
			xdo move -x 137 -y 77 # Centralizar janela no monitor [x, y]
			WINDOW_RESIZED["$1"]=0
		}
}

# $1=NODE; $2=DESKTOP
window_focus_floating(){
	local is_window_tiled=$(bspc query -T -d "$2" -n "$1" | jq -M '.client.state' | sed "s/\"//g")
	# Se STATE já for floating, não dar resized
	[[ $is_window_tiled != floating ]] &&
		{
			# Se existir somente uma janela, não mudar STATE
			if (( $(get_leaf_number "$2") > 1 )) 
			then
				bspc node any.floating -t tiled 
				bspc node "$1" -t floating 
				set_window_whxy "$1"
			else
				bspc node "$1" -t tiled 
			fi
		}
}

# Funções com mesmo nome do evento

# $1=MONITOR; $2=DESKTOP; $3=NODE
node_focus(){
	# Ao focar um NODE, tranformá-lo em floating
	window_focus_floating "$3" "$2"
}

# $1=MONITOR; $2=DESKTOP; $3=NODE_REMOVED
node_remove(){
	# Seta para 1 [false] quando NODE é removido
	WINDOW_RESIZED["$3"]=1
}

# $1=MONITOR; $2=DESKTOP
desktop_focus(){
	# Atualizar statusbar (lemonbar)
	pkill -f "sleep 1m"
}

main(){
	# Utilizar os node_event's para interpretar os comandos
	while read EVENTO
	do
		$EVENTO
	#done < <(bspc subscribe node_focus node_state node_stack node_add node_remove desktop_focus)
	done < <(bspc subscribe node_focus desktop_focus node_remove)
}

main
