#!/usr/bin/env bash

# TODO - Ficar atento aos comandos nos loop's "for", pois eles não estão "quotados"
# Este script estará sempre rodando em background. Utiliza script para atualizar statusbar [lemonbar]

init_variables(){
	# Sempre usar esta forma de declaração para arrays associativos [key]=value
	declare -A WINDOW_RESIZED
	get_monitor_xy
	RATIO=9 # Calcula o tamanha da janela pela porcentagem do monitor
	WIDTH=$(( (MONITOR_XY[0]*RATIO)/10 ))
	HEIGTH=$(( (MONITOR_XY[1]*RATIO)/10 ))
	X=$(( (MONITOR_XY[0]-WIDTH)/2 ))
	Y=$(( (MONITOR_XY[1]-HEIGTH)/2 ))
}

get_monitor_xy(){
	local IFS='x'
	MONITOR_XY=($(xdpyinfo | sed -n "/dimensions/p" | sed "s/\ /-/g" | cut -d'-' -f7))
}


# "Printa" número de NODE's no DESKTOP em foco
get_leafs_number(){
	local num_windows=0
	for id in $(bspc query -N -d "$1" -n .leaf)
	do
		((num_windows++))
	done
	echo "$num_windows"
}

set_window_whxy(){
	[[ -z ${WINDOW_RESIZED[$1]} ]] && WINDOW_RESIZED["$1"]=0
	(( ! ${WINDOW_RESIZED[$1]} )) && {
			# Redimensiona o NODE
			xdo resize -w "$WIDTH" -h "$HEIGTH"
			xdo move -x "$X" -y "$Y" # Centralizar janela no monitor [x, y]
			WINDOW_RESIZED["$1"]=1
		}
}

# $1=NODE; $2=DESKTOP
window_focus_floating(){
	local is_window_tiled=$(bspc query -T -d "$2" -n "$1" | jq -M '.client.state' | sed "s/\"//g")
	# Se STATE já for floating, não dar resized
	[[ $is_window_tiled != floating ]] && {
			# Se existir somente uma janela, não mudar STATE
			if (( $(get_leafs_number "$2") > 1 )) 
			then
				bspc node any.floating -t tiled 
				bspc node "$1" -t floating 
				set_window_whxy "$1"
			else
				bspc node "$1" -t tiled 
			fi
		}
}

# Funções com mesmo nome do evento

# $1=MONITOR; $2=DESKTOP; $3=NODE
node_focus(){
	# Ao focar um NODE, tranformá-lo em floating
	window_focus_floating "$3" "$2"
}

# $1=MONITOR; $2=DESKTOP; $3=NODE_REMOVED
node_remove(){
	# BUG: Nem todos os NODES são removidos... Deve-se usar comando correto para remover os nodes [ bspc node -c ]
	unset WINDOW_RESIZED["$3"]
}

main(){
	init_variables
	# Utilizar os node_event's para interpretar os comandos
	while read EVENTO
	do
		# Como eu preciso que os espaços sejam interpretados como separador de argumentos, eu não uso aspas
		$EVENTO
	#done < <(bspc subscribe node_focus node_state node_stack node_add node_remove desktop_focus)
	done < <(bspc subscribe node_focus node_remove)
}

main
